# $Id$

PortSystem          1.0

name                minivmac
version             3.0.4
revision            1
categories          emulators aqua
maintainers         ryandesign
homepage            http://minivmac.sourceforge.net/
use_zip             yes
platforms           macosx
universal_variant   no
build.target
use_parallel_build  yes

description \
	a Mac 128K, Mac 512K, Mac 512KE, Mac Plus and Mac SE emulator

long_description \
	Mini vMac is a Macintosh emulator. It emulates the earliest Macs, \
	from the original Mac 128K (built 1984-85) to the Mac SE (1987-1990). \
	The default is to emulate a Mac Plus (1986-1990)\; this is also \
	the best-tested and therefore recommended emulation.

master_sites \
	sourceforge:${name}:minivmac \
	http://download.info.apple.com/Apple_Support_Area/Apple_Software_Updates/English-International/Macintosh/System/Full_Installs/:apple

set my_src                                  ${distname}.src
set my_src_compressed                       ${my_src}.zip
set my_bootstrap_version                    3.0.4
set my_bootstrap                            "Mini vMac.app"
set my_bootstrap_compressed                 ${name}-${my_bootstrap_version}-umch.bin.tgz
set my_autoquit                             autquit7-1.1.0
set my_autoquit_compressed                  ${my_autoquit}.zip
set my_icons                                icnsosx-1.0.0
set my_icons_compressed                     ${my_icons}.zip
set my_system_disk_container                Z-System_7.0.1.smi
set my_system_disk_container_compressed     ${my_system_disk_container}.bin

distfiles \
	${my_src_compressed}:minivmac \
	${my_icons_compressed}:minivmac \
	${my_autoquit_compressed}:minivmac \
	${my_system_disk_container_compressed}:apple

extract.only \
	${my_src_compressed} \
	${my_icons_compressed} \
	${my_autoquit_compressed}

checksums \
	${my_src_compressed} \
		md5 ab308459e98bd5103ad8bbb7dd158eb6 \
		sha1 ff99aa72da0868a5306631f0d06ae190cbd2a03a \
		rmd160 b8f1f5269d21835ff3e9e428da12a7b6c224e60e \
	${my_bootstrap_compressed} \
		md5 298565ec1ccfe6876768156aaf5f76a0 \
		sha1 34212dedb1cfb744e6ca8124693f2f6e40094833 \
		rmd160 042eacfb9ec853589d661c86ffb99d509061eb0f \
	${my_icons_compressed} \
		md5 2af006506de7549be14f94317918d59a \
		sha1 4ef79bb56b988fedfeb82a8b6cafd8066f5bbab2 \
		rmd160 cef6d7d7578464538d0042b0d98379ae7f18fab7 \
	${my_autoquit_compressed} \
		md5 eebe87a27d6db8e8f247f0fffe0f2bd5 \
		sha1 8199e1da12d01fc210ae1eaa50f794e5b8c479c1 \
		rmd160 f493a59fd637caa8a7937fbefaf6ebdf4a07c7f5 \
	${my_system_disk_container_compressed} \
		md5 5e7b4c0ce13e65546eb795c35879751a \
		sha1 bf37fde76dfd9d4ed35526954c149566d761c2a6 \
		rmd160 08788cbcca023ea9a0713ecec4781c35aa5a9185

depends_build \
	port:macutil \
	bin:expect:expect

set my_appdir "${applications_dir}/Mini vMac"
set romfile vMac.ROM
set romfile_model "Macintosh Plus or 512Ke"
set my_mnvm_dat "${workpath}/${my_bootstrap}/Contents/mnvm_dat"
set my_options_file options.txt
set my_base_options "-maintainer MacPorts -homepage http://www.macports.org/ -cl -eol unx -nex"
set my_target ""
set my_machine Plus
set my_variation_machine mac[string tolower ${my_machine}]

platform powerpc {
	set my_target mach
}

platform i386 {
	set my_target imch
}

pre-fetch {
	if { ! [file exists ${my_appdir}/${romfile}] } {
		ui_msg "**************************************************************"
		ui_msg "Mini vMac requires a ROM file from the type of machine you're"
		ui_msg "emulating in order to work. The ROM file is not included with"
		ui_msg "this package because it is copyrighted Apple software."
		ui_msg "Download the CopyRoms program from the Mini vMac web site"
		ui_msg "(${homepage} > More > Extras)"
		ui_msg "and transfer it to a real physical ${romfile_model}"
		ui_msg "that you own. Run the CopyRoms program there, then transfer"
		ui_msg "the ROM file back to this Mac, name it ${romfile},"
		ui_msg "and put it in ${my_appdir}."
		ui_msg "**************************************************************"
		return -code error "missing ROM file"
	}
}

post-extract {
	system "tar -x -z -C ${workpath} -f ${distpath}/${my_bootstrap_compressed}"
	
	xinstall -W ${filespath} attach.exp demacbinary.sh ${workpath}
	
	system "${workpath}/demacbinary.sh ${distpath}/${my_system_disk_container_compressed} ${workpath}"
	
	file mkdir ${my_mnvm_dat}
	ln -s ${my_appdir}/${romfile} ${my_mnvm_dat}
	
	# Copy the Disk Tools and Tidbits images from the container image.
	set my_system_disk_container_mount [my_attach_disk_image ${workpath}/${my_system_disk_container} 0]
	file copy "${my_system_disk_container_mount}/Disk Tools.image" ${workpath}/startup.img
	file copy "${my_system_disk_container_mount}/Tidbits.image" ${workpath}/tidbits.img
	my_detach_disk_image ${my_system_disk_container_mount}
	
	# The disk image mounter likes images to have the .img extension.
	file rename ${workpath}/${my_src}/${my_src}.dsk ${workpath}/src.img
	file rename ${workpath}/${my_autoquit}/${my_autoquit}.dsk ${workpath}/autoquit.img
	
	# Mount the startup disk and make room on it for our things.
	set my_startup_disk_mount [my_attach_disk_image ${workpath}/startup.img 1]
	file delete "${my_startup_disk_mount}/Apple HD SC Setup" "${my_startup_disk_mount}/Disk First Aid"
	
	# Copy autoquit to the startup disk and make it open at startup.
	# Need to use ditto to preserve the resource fork.
	set my_autoquit_disk_mount [my_attach_disk_image ${workpath}/autoquit.img 0]
	set my_startup_disk_autoquit_dir "${my_startup_disk_mount}/autoquit"
	file mkdir "${my_startup_disk_autoquit_dir}"
	system "ditto --rsrc ${my_autoquit_disk_mount}/AutQuit7 ${my_startup_disk_autoquit_dir}"
	my_detach_disk_image ${my_autoquit_disk_mount}
	my_make_alias "${my_startup_disk_autoquit_dir}/AutQuit7" "${my_startup_disk_mount}/System Folder/Startup Items"
	
	# Mount the source disk.
	set my_src_disk_mount [my_attach_disk_image ${workpath}/src.img 1]
	
	# Copy TeachText to the source disk. (No room on the startup disk.)
	set my_tidbits_disk_mount [my_attach_disk_image ${workpath}/tidbits.img 0]
	system "ditto --rsrc ${my_tidbits_disk_mount}/TeachText ${my_src_disk_mount}"
	my_detach_disk_image ${my_tidbits_disk_mount}
	
	# Force a rebuild of the Desktop files, both to add info about TeachText and
	# to remove that of Apple HD SC Setup and Disk First Aid (to make more room).
	file delete ${my_startup_disk_mount}/Desktop ${my_src_disk_mount}/Desktop
	
	# Create an empty options file so we can make an alias to it.
	set my_options_file_id [open ${my_src_disk_mount}/${my_options_file} "w"]
	close ${my_options_file_id}
	system "/Developer/Tools/SetFile -c ttxt -t TEXT ${my_src_disk_mount}/${my_options_file}"
	
	# Have autoquit launch the build system. If there's an alias "app" in the same directory,
	# autoquit will open it. If there's also an alias "doc" in the same directory, autoquit
	# will open the document "doc" into the application "app".
	my_make_alias "${my_src_disk_mount}/Build" "${my_startup_disk_autoquit_dir}/app"
	# The build system doesn't support reading text files yet.
#	my_make_alias "${my_src_disk_mount}/${my_options_file}" "${my_startup_disk_autoquit_dir}/doc"
	my_make_alias "${my_src_disk_mount}/${my_options_file}" "${my_startup_disk_mount}/System Folder/Startup Items"
	
	# Unmount disk images.
	my_detach_disk_image ${my_startup_disk_mount}
	my_detach_disk_image ${my_src_disk_mount}
	
	# Mini vMac looks for disks named disk1.dsk through disk3.dsk and automounts them.
	file rename "${workpath}/startup.img" "${my_mnvm_dat}/disk1.dsk"
}

configure {
	# Write our options file.
	set my_variation [my_get_variation]
	set my_options "${my_base_options} -t ${my_target} -m ${my_machine} -n ${my_variation}"
	set my_src_disk_mount [my_attach_disk_image ${workpath}/src.img 1]
	set my_options_file_id [open ${my_src_disk_mount}/${my_options_file} "w"]
	puts -nonewline ${my_options_file_id} ${my_options}
	close ${my_options_file_id}
	my_detach_disk_image ${my_src_disk_mount}
	
	# Move the source disk where Mini vMac will find it.
	file rename "${workpath}/src.img" "${my_mnvm_dat}/disk2.dsk"
	
	# Run the build system.
	system "'${workpath}/${my_bootstrap}/Contents/MacOS/minivmac'"
	
	# Give the source disk image the .img extension to appease the disk image mounter.
	file rename "${my_mnvm_dat}/disk2.dsk" "${workpath}/src.img"
	
	# Get the build product.
	set my_src_disk_mount [my_attach_disk_image ${workpath}/src.img 1]
	if {[file exists ${my_src_disk_mount}/output/${my_variation}]} {
		file copy ${my_src_disk_mount}/output/${my_variation} ${workpath}
		file delete -force ${my_src_disk_mount}/output/${my_variation}
	}
	my_detach_disk_image ${my_src_disk_mount}
}

pre-build {
	set my_variation [my_get_variation]
	build.dir ${workpath}/${my_variation}
}

post-build {
	set my_variation [my_get_variation]
	eval xinstall -m 644 [glob ${workpath}/${my_icons}/icons/*.icns] ${workpath}/${my_variation}/minivmac.app/Contents/Resources
}

destroot {
	set my_variation [my_get_variation]
	xinstall -d ${destroot}${my_appdir}
	file copy ${workpath}/${my_variation}/minivmac.app \
		${destroot}${my_appdir}/Mini\ vMac\ ${my_machine}.app
}

if { ![variant_isset mac128k] && ![variant_isset mac512k] && ![variant_isset mac512ke] && ![variant_isset macse] } {
	default_variants +macplus
}

variant mac128k conflicts mac512k mac512ke macplus macse description {Emulate a Macintosh with 128K RAM and 2 drives} {
	patchfiles-append patch-CNFGGLOB.h-mac128k.diff
	set romfile Mac128K.ROM
	set romfile_model "Macintosh 128K or 512K"
}

variant mac512k conflicts mac128k mac512ke macplus macse description {Emulate a Macintosh 512K with 512K RAM and 2 drives} {
	patchfiles-append patch-CNFGGLOB.h-mac512k.diff
	set romfile Mac128K.ROM
	set romfile_model "Macintosh 128K or 512K"
}

variant mac512ke conflicts mac128k mac512k macplus macse description {Emulate a Macintosh 512Ke with 512K RAM and 6 drives} {
	patchfiles-append patch-CNFGGLOB.h-mac512ke.diff
}

variant macplus conflicts mac128k mac512k mac512ke macse description {Emulate a Macintosh Plus with 4 MB RAM and 6 drives (default)} {
	# Mac Plus emulation is the default so we don't need to do anything here
}

variant macse conflicts mac128k mac512k mac512ke macplus description {Emulate a Macintosh SE with 4 MB RAM and 6 drives} {
	patchfiles-append patch-CNFGGLOB.h-macse.diff
	set romfile MacSE.ROM
	set romfile_model "Macintosh SE"
}

proc my_attach_disk_image {disk_image allow_writing} {
	global name workpath
	set mountpoint [exec mktemp -d -q -t ${name}]
	# Use this expect script instead of using hdiutil directly, because the
	# system disk image has a license agreement we must agree to.
	system "${workpath}/attach.exp '${disk_image}' '${mountpoint}' '${allow_writing}'"
	return ${mountpoint}
}

proc my_detach_disk_image {mountpoint} {
	system "hdiutil detach ${mountpoint} -force"
	file delete -force ${mountpoint}
}

proc my_make_alias {src dst} {
	set dst_is_dir [file isdirectory "${dst}"]
	if {${dst_is_dir}} {
		set dst_dir "${dst}"
	} else {
		set dst_dir "[file dirname ${dst}]"
	}
	system "osascript -e 'set src to POSIX file \"${src}\"' -e 'set dst_dir to POSIX file \"${dst_dir}\"' -e 'tell app \"Finder\" to make new alias file at dst_dir to src' -e 'return'"
	if {!${dst_is_dir}} {
		file rename "[file join ${dst_dir} [file tail ${src}]]" "${dst}"
	}
}

proc my_get_variation {} {
	global name version revision my_variation_machine my_target
	return ${name}-${version}_${revision}-${my_variation_machine}-${my_target}
}

livecheck.check     regex
livecheck.url       ${homepage}download.html
livecheck.regex     ${name}-(\[0-9.\]+)\\.src
