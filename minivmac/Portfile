# $Id$

PortSystem          1.0

name                minivmac
version             3.0.4
categories          emulators aqua
maintainers         ryandesign
homepage            http://minivmac.sourceforge.net/
use_zip             yes
platforms           macosx
universal_variant   no

description \
	a Mac 128K, Mac 512K, Mac 512KE, Mac Plus and Mac SE emulator

long_description \
	Mini vMac is a Macintosh emulator. It emulates the earliest Macs, \
	from the original Mac 128K (built 1984-85) to the Mac SE (1987-1990). \
	The default is to emulate a Mac Plus (1986-1990)\; this is also \
	the best-tested and therefore recommended emulation.

master_sites \
	sourceforge:${name}:minivmac \
	http://download.info.apple.com/Apple_Support_Area/Apple_Software_Updates/English-International/Macintosh/System/Full_Installs/:apple

set my_src                                  ${distname}.src
set my_src_compressed                       ${my_src}.zip
set my_bootstrap_version                    3.0.4
set my_bootstrap                            "Mini vMac.app"
set my_bootstrap_compressed                 ${name}-${my_bootstrap_version}-umch.bin.tgz
set my_autoquit                             autquit7-1.1.0
set my_autoquit_compressed                  ${my_autoquit}.zip
set my_system_disk_container                Z-System_7.0.1.smi
set my_system_disk_container_compressed     ${my_system_disk_container}.bin

distfiles \
	${my_src_compressed}:minivmac \
	${my_autoquit_compressed}:minivmac \
	${my_system_disk_container_compressed}:apple

extract.only \
	${my_src_compressed} \
	${my_autoquit_compressed}

checksums \
	${my_src_compressed} \
		md5 ab308459e98bd5103ad8bbb7dd158eb6 \
		sha1 ff99aa72da0868a5306631f0d06ae190cbd2a03a \
		rmd160 b8f1f5269d21835ff3e9e428da12a7b6c224e60e \
	${my_bootstrap_compressed} \
		md5 298565ec1ccfe6876768156aaf5f76a0 \
		sha1 34212dedb1cfb744e6ca8124693f2f6e40094833 \
		rmd160 042eacfb9ec853589d661c86ffb99d509061eb0f \
	${my_autoquit_compressed} \
		md5 eebe87a27d6db8e8f247f0fffe0f2bd5 \
		sha1 8199e1da12d01fc210ae1eaa50f794e5b8c479c1 \
		rmd160 f493a59fd637caa8a7937fbefaf6ebdf4a07c7f5 \
	${my_system_disk_container_compressed} \
		md5 5e7b4c0ce13e65546eb795c35879751a \
		sha1 bf37fde76dfd9d4ed35526954c149566d761c2a6 \
		rmd160 08788cbcca023ea9a0713ecec4781c35aa5a9185

depends_build \
	port:macutil \
	bin:expect:expect

set my_appdir "/Applications/MacPorts/Mini vMac"
set romfile vMac.ROM
set romfile_model "Macintosh Plus or 512Ke"
set my_mnvm_dat "${workpath}/${my_bootstrap}/Contents/mnvm_dat"

pre-fetch {
	if { ! [file exists ${my_appdir}/${romfile}] } {
		ui_msg "**************************************************************"
		ui_msg "Mini vMac requires a ROM file from the type of machine you're"
		ui_msg "emulating in order to work. The ROM file is not included with"
		ui_msg "this package because it is copyrighted Apple software."
		ui_msg "Download the CopyRoms program from the Mini vMac web site"
		ui_msg "(${homepage} > More > Extras)"
		ui_msg "and transfer it to a real physical ${romfile_model}"
		ui_msg "that you own. Run the CopyRoms program there, then transfer"
		ui_msg "the ROM file back to this Mac, name it ${romfile},"
		ui_msg "and put it in ${my_appdir}."
		ui_msg "**************************************************************"
		return -code error "missing ROM file"
	}
}

post-extract {
	system "tar -x -z -C ${workpath} -f ${distpath}/${my_bootstrap_compressed}"
	
	xinstall -W ${filespath} attach.exp demacbinary.sh ${workpath}
	
	system "${workpath}/demacbinary.sh ${distpath}/${my_system_disk_container_compressed} ${workpath}"
	
	file mkdir ${my_mnvm_dat}
	file copy ${my_appdir}/${romfile} ${my_mnvm_dat}
	
	# Copy the Disk Tools image from the container image.
	set my_system_disk_container_mount [my_attach_disk_image ${workpath}/${my_system_disk_container} 0]
	file copy "${my_system_disk_container_mount}/Disk Tools.image" ${workpath}/startup.img
	my_detach_disk_image ${my_system_disk_container_mount}
	
	# The disk image mounter likes images to have the .img extension.
	file rename ${workpath}/${my_src}/${my_src}.dsk ${workpath}/src.img
	file rename ${workpath}/${my_autoquit}/${my_autoquit}.dsk ${workpath}/autoquit.img
	
	# Mount disk images.
	set my_autoquit_disk_mount [my_attach_disk_image ${workpath}/autoquit.img 0]
	set my_src_disk_mount [my_attach_disk_image ${workpath}/src.img 0]
	set my_startup_disk_mount [my_attach_disk_image ${workpath}/startup.img 1]
	
	# Make room on the startup disk for our things.
	file delete "${my_startup_disk_mount}/Apple HD SC Setup" "${my_startup_disk_mount}/Disk First Aid"
	
	# Set up autoquit.
	set my_startup_disk_autoquit_dir "${my_startup_disk_mount}/autoquit"
	file mkdir "${my_startup_disk_autoquit_dir}"
	# Need to copy this with the resource fork.
	system "ditto --rsrc ${my_autoquit_disk_mount}/AutQuit7 ${my_startup_disk_autoquit_dir}"
	# Launch autoquit at startup.
	my_make_alias "${my_startup_disk_autoquit_dir}/AutQuit7" "${my_startup_disk_mount}/System Folder/Startup Items"
	# Have autoquit launch the build system. autoquit will open an app named "app" in its directory.
	my_make_alias "${my_src_disk_mount}/Build" "${my_startup_disk_autoquit_dir}/app"
	
	# Unmount disk images.
	my_detach_disk_image ${my_startup_disk_mount}
	my_detach_disk_image ${my_src_disk_mount}
	my_detach_disk_image ${my_autoquit_disk_mount}
	
	# Mini vMac looks for disks named disk1.dsk through disk3.dsk and automounts them.
	file rename "${workpath}/startup.img" "${my_mnvm_dat}/disk1.dsk"
	file rename "${workpath}/src.img" "${my_mnvm_dat}/disk2.dsk"
	
#	reinplace "s|maintained by unknown|maintained by MacPorts|" \
#		${worksrcpath}/config/Info.plist
#	reinplace "s|#define kMaintainerName \"unknown\"|#define kMaintainerName \"MacPorts\"|" \
#		${worksrcpath}/config/CNFGGLOB.h
}

configure {
	system "'${workpath}/${my_bootstrap}/Contents/MacOS/minivmac'"
	return -code error "portfile incomplete! :("
}

if { ![variant_isset mac128k] && ![variant_isset mac512k] && ![variant_isset mac512ke] && ![variant_isset macse] } {
	default_variants +macplus
}

variant mac128k conflicts mac512k mac512ke macplus macse description {Emulate a Macintosh with 128K RAM and 2 drives} {
	patchfiles-append patch-CNFGGLOB.h-mac128k.diff
	set romfile Mac128K.ROM
	set romfile_model "Macintosh 128K or 512K"
}

variant mac512k conflicts mac128k mac512ke macplus macse description {Emulate a Macintosh 512K with 512K RAM and 2 drives} {
	patchfiles-append patch-CNFGGLOB.h-mac512k.diff
	set romfile Mac128K.ROM
	set romfile_model "Macintosh 128K or 512K"
}

variant mac512ke conflicts mac128k mac512k macplus macse description {Emulate a Macintosh 512Ke with 512K RAM and 6 drives} {
	patchfiles-append patch-CNFGGLOB.h-mac512ke.diff
}

variant macplus conflicts mac128k mac512k mac512ke macse description {Emulate a Macintosh Plus with 4 MB RAM and 6 drives (default)} {
	# Mac Plus emulation is the default so we don't need to do anything here
}

variant macse conflicts mac128k mac512k mac512ke macplus description {Emulate a Macintosh SE with 4 MB RAM and 6 drives} {
	patchfiles-append patch-CNFGGLOB.h-macse.diff
	set romfile MacSE.ROM
	set romfile_model "Macintosh SE"
}

proc my_attach_disk_image {disk_image allow_writing} {
	global name workpath
	set mountpoint [exec mktemp -d -q -t ${name}]
	# Use this expect script instead of using hdiutil directly, because the
	# system disk image has a license agreement we must agree to.
	system "${workpath}/attach.exp '${disk_image}' '${mountpoint}' '${allow_writing}'"
	return ${mountpoint}
}

proc my_detach_disk_image {mountpoint} {
	system "hdiutil detach ${mountpoint} -force"
	file delete -force ${mountpoint}
}

proc my_make_alias {src dst} {
	set dst_is_dir [file isdirectory "${dst}"]
	if {${dst_is_dir}} {
		set dst_dir "${dst}"
	} else {
		set dst_dir "[file dirname ${dst}]"
	}
	system "osascript -e 'set src to POSIX file \"${src}\"' -e 'set dst_dir to POSIX file \"${dst_dir}\"' -e 'tell app \"Finder\" to make new alias file at dst_dir to src' -e 'return'"
	if {!${dst_is_dir}} {
		file rename "[file join ${dst_dir} [file tail ${src}]]" "${dst}"
	}
}

livecheck.check     regex
livecheck.url       ${homepage}download.html
livecheck.regex     ${name}-(\[0-9.\]+)\\.src
